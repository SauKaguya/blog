<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>面向对象：理解Kotlin设计者的良苦用心 | blog</title>
    <meta name="generator" content="VuePress 1.8.0">
    <link rel="icon" href="https://cdn.jsdelivr.net/gh/eryajf/tu/img/image_20220720_132133.ico">
    <script language="javascript" type="text/javascript" src="/blog/js/pgmanor-self.js"></script>
    <meta name="description" content="vdoing博客主题模板">
    <meta name="keywords" content="二丫讲梵,golang,vue,go-web,go-admin,go-ldap-admin">
    <meta name="theme-color" content="#11a8cd">
    <meta name="referrer" content="no-referrer-when-downgrade">
    
    <link rel="preload" href="/blog/assets/css/0.styles.2ab958c7.css" as="style"><link rel="preload" href="/blog/assets/js/app.0eb42f52.js" as="script"><link rel="preload" href="/blog/assets/js/2.409f7334.js" as="script"><link rel="preload" href="/blog/assets/js/9.ed0bb6e8.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.b6f101db.js"><link rel="prefetch" href="/blog/assets/js/11.d9c37418.js"><link rel="prefetch" href="/blog/assets/js/12.ed2b7d28.js"><link rel="prefetch" href="/blog/assets/js/13.fcd4c96b.js"><link rel="prefetch" href="/blog/assets/js/14.6632ddbe.js"><link rel="prefetch" href="/blog/assets/js/15.6214df8b.js"><link rel="prefetch" href="/blog/assets/js/16.17686675.js"><link rel="prefetch" href="/blog/assets/js/3.bb88b7d1.js"><link rel="prefetch" href="/blog/assets/js/4.8016aaad.js"><link rel="prefetch" href="/blog/assets/js/5.a96f73bb.js"><link rel="prefetch" href="/blog/assets/js/6.f9f36310.js"><link rel="prefetch" href="/blog/assets/js/7.940eef01.js"><link rel="prefetch" href="/blog/assets/js/8.bc117534.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.2ab958c7.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="https://cdn.jsdelivr.net/gh/eryajf/tu/img/image_20220720_132208.png" alt="blog" class="logo"> <span class="site-name can-hide">blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">首页</a></div><div class="nav-item"><a href="/blog/one/" class="nav-link">编程</a></div><div class="nav-item"><a href="/blog/two/" class="nav-link">杂谈</a></div><div class="nav-item"><a href="/blog/three/" class="nav-link">运维</a></div><div class="nav-item"><a href="/blog/message-board/" class="nav-link">留言板</a></div> <a href="https://github.com/saukaguya/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">首页</a></div><div class="nav-item"><a href="/blog/one/" class="nav-link">编程</a></div><div class="nav-item"><a href="/blog/two/" class="nav-link">杂谈</a></div><div class="nav-item"><a href="/blog/three/" class="nav-link">运维</a></div><div class="nav-item"><a href="/blog/message-board/" class="nav-link">留言板</a></div> <a href="https://github.com/saukaguya/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/blog/pages/9f74b6/" class="sidebar-link">Kotlin基础语法：正式开启学习之旅</a></li><li><a href="/blog/pages/952198/" aria-current="page" class="active sidebar-link">面向对象：理解Kotlin设计者的良苦用心</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/blog/pages/952198/#怎么写出有kotlin特点的类" class="sidebar-link">怎么写出有Kotlin特点的类？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/blog/pages/952198/#自定义属性getter" class="sidebar-link">自定义属性getter</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/952198/#自定义属性setter" class="sidebar-link">自定义属性setter</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/blog/pages/952198/#抽象类与继承" class="sidebar-link">抽象类与继承</a></li><li class="sidebar-sub-header level2"><a href="/blog/pages/952198/#接口和实现" class="sidebar-link">接口和实现</a></li><li class="sidebar-sub-header level2"><a href="/blog/pages/952198/#嵌套" class="sidebar-link">嵌套</a></li><li class="sidebar-sub-header level2"><a href="/blog/pages/952198/#kotlin中的特殊类" class="sidebar-link">Kotlin中的特殊类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/blog/pages/952198/#数据类" class="sidebar-link">数据类</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/952198/#密封类" class="sidebar-link">密封类</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/blog/pages/952198/#小结" class="sidebar-link">小结</a></li></ul></li><li><a href="/blog/pages/31d2bd/" class="sidebar-link">Kotlin中的object</a></li><li><a href="/blog/pages/b7368f/" class="sidebar-link">Kotlin中为什么要有field</a></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/blog/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/blog/one/#one" data-v-06225672>one</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/saukaguya" target="_blank" title="作者" class="beLink" data-v-06225672>Saukaguya</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2024-06-12</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">面向对象：理解Kotlin设计者的良苦用心<!----></h1> <!----> <div class="theme-vdoing-content content__default"><h1 id="_02-面向对象-理解kotlin设计者的良苦用心"><a href="#_02-面向对象-理解kotlin设计者的良苦用心" class="header-anchor">#</a> 02 | 面向对象：理解Kotlin设计者的良苦用心</h1> <p>在“面向对象”的概念上，虽然Kotlin和Java之间有一定的语法差异，但底层的思想是没有变的。比如Java和Kotlin当中，都有类、接口、继承、嵌套、枚举的概念，唯一区别就在于这些概念在两种语言中的具体语法不同。 <strong>我们需要做的，仅仅只是为我们脑海里已经熟知的概念，再增加一种语法规则而已。</strong></p> <p>当然，Kotlin作为一门新的语言，它也创造了一些新的东西，比如数据类、密封类、密封接口等。这些Kotlin的新概念，会是我们需要着重学习的对象。 <strong>实际上，也正是因为Kotlin的这些独有概念，使得它形成了一种独特的编程风格和编程思想。</strong></p> <h2 id="怎么写出有kotlin特点的类"><a href="#怎么写出有kotlin特点的类" class="header-anchor">#</a> 怎么写出有Kotlin特点的类？</h2> <p>Kotlin当中的“类”，我们可以将其理解为对某种事物的“抽象模型”。比如说，我们可以在Kotlin当中定义一个类，它叫做Person。</p> <div class="language-plain line-numbers-mode"><pre class="language-plain"><code>class Person(val name: String, var age: Int)

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>计算机的世界里当然没有“人”的概念，但是这并不妨碍我们在代码当中定义一个人的“抽象模型”。上面的Person类当中，有一个属性，叫做“name”，每个人都会有名字，而名字也是属于人的一部分。这也很好理解，对吧。</p> <p>不过，如果你以Java的角度来分析上面的代码的话，会发现它并没有表面上那么简单。如果我们将其翻译成等价的Java代码，它会变成很多行代码：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 属性 name 没有 setter</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>那么，把Kotlin和Java的代码对比着来看，我们很快就会发现，Kotlin当中，Person类的 <strong>name是用val修饰的</strong>，这意味着，它在初始化以后将无法被修改。这个逻辑对应到Java当中，就是该变量只有getter没有setter。而Kotlin当中，Person类的 <strong>age是var修饰的</strong>，意味着它是可以被随意修改的。这个逻辑对应到Java当中，就是该变量既有getter也有setter。</p> <p>这下你应该就明白了， <strong>Kotlin定义的类，在默认情况下是public的</strong>，编译器会帮我们生成“构造函数”，对于类当中的属性，Kotlin编译器也会根据实际情况，自动生成getter和setter。</p> <p>到这里，我们不得不感叹Kotlin语言的简洁性。Kotlin里简单到不能再简单的一行代码，在Java中却要写这么一大串。要注意，这里的差距并不仅仅是我们程序员敲代码的时间，还包括后续我们迭代维护的时间，或者说是读代码的时间。Kotlin一行代码，我们轻松就能理解了，而对应的Java则完全不一样。并且，这还只是一个最简单的案例，真实的程序比这复杂千万倍。</p> <h3 id="自定义属性getter"><a href="#自定义属性getter" class="header-anchor">#</a> 自定义属性getter</h3> <p>我们继续来看前面的Person类的例子。如果这时候，我们希望它增加一个功能，就是根据年龄的大小自动判断是不是成年人，也就是age≥18。</p> <p>如果按照我们从前的Java思维，一定会习以为常地写出下面这样的代码，也就是为Person类增加一个新的方法：isAdult()。</p> <div class="language-plain line-numbers-mode"><pre class="language-plain"><code>class Person(val name: String, var age: Int) {
    fun isAdult(): Boolean {
        return age &gt;= 18
    }
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>又或者，我们可以充分发挥Kotlin的简洁语法特性，将isAdult()写得更加清爽一些：</p> <div class="language-plain line-numbers-mode"><pre class="language-plain"><code>class Person(val name: String, var age: Int) {
    fun isAdult() = age &gt;= 18
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>代码写成这样，已经算不错了。然而，我们还可以用另一种更符合直觉的写法，那就是将isAdult()定义成Person的属性。具体的做法，就是借助Kotlin属性的 <strong>自定义getter</strong>。</p> <div class="language-plain line-numbers-mode"><pre class="language-plain"><code>class Person(val name: String, var age: Int) {
    val isAdult
        get() = age &gt;= 18
//        ↑
//    这就是isAdult属性的getter方法
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>所谓getter，就是 <strong>获取属性值的方法</strong>。我们通过自定义这个get()方法，就可以改变返回值的规则。比如，这里的年龄大于等于18，就是成年人，这个规则就是通过自定义来实现的。</p> <p>以上的isAdult属性，我们省略了它的类型，因为编译器会自动推导它的类型是Boolean（布尔）类型。另外，由于get()方法内部只有一行代码，我们使用了函数的“单一表达式”写法，直接用等号连接即可。</p> <p>而如果get()方法内部的逻辑比较复杂，我们仍然可以像正常函数那样，带上花括号：</p> <div class="language-plain line-numbers-mode"><pre class="language-plain"><code>class Person(val name: String, var age: Int) {
    val isAdult: Boolean
        get() {
            // do something else
            return age &gt;= 18
        }
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>不过需要注意的是，在这种情况下，编译器的自动类型推导就会失效了，所以我们要为isAdult属性增加明确的类型：Boolean。</p> <p>看到这里，也许你会觉得奇怪：判断一个人是否为成年人，我们只需要判断age这个属性即可， <strong>为什么还要引入一个新的属性isAdult呢？</strong> 这不是凭空多占用了一个变量的内存吗？这么做是否有必要？</p> <p>实际上，这里涉及到Java到Kotlin的一种思想转变。让我们来详细分解上面的问题：</p> <ul><li>首先， <strong>从语法的角度</strong> 上来说，是否为成年人，本来就是属于人身上的一种属性。我们在代码当中将其定义为属性，更符合直觉。而如果我们要给Person增加一个行为，比如walk，那么这种情况下定义一个新的方法就是非常合适的。</li> <li>其次， <strong>从实现层面</strong> 来看，我们确实定义了一个新的属性isAdult，但是Kotlin编译器能够分析出，我们这个属性实际是根据age来做逻辑判断的。在这种情况下，Kotlin编译器可以在JVM层面，将其优化为一个方法。</li> <li>通过以上两点，我们就成功在语法层面有了一个isAdult属性；但是 <strong>在实现层面，isAdult仍然还是个方法</strong>。这也就意味着，isAdult本身不会占用内存，它的性能和我们用Java写的方法是一样的。而这在Java当中是无法实现的。</li></ul> <p>所以，当你使用Kotlin来编写代码的时候，一定要注意其中引入的Kotlin属性的含义，并且理解它的底层实现逻辑。只有这样，你才能真正发挥Kotlin简洁语法的优势，而不必束缚在Java或者C的代码撰写思维里。</p> <h3 id="自定义属性setter"><a href="#自定义属性setter" class="header-anchor">#</a> 自定义属性setter</h3> <p>我们继续来看前面的Person案例，假设这时候我们又来了一个新的需求，希望在age被修改的时候，能够做一些日志统计工作。如果是Java，那我们直接在setAge()方法当中加入一些逻辑就行了。</p> <p>可是在Kotlin当中，我们要怎么办呢？答案也很容易想到， <strong>自定义setter</strong>。</p> <div class="language-plain line-numbers-mode"><pre class="language-plain"><code>class Person(val name: String) {
    var age: Int = 0
//  这就是age属性的setter
//       ↓
        set(value: Int) {
            log(value)
            field = value
        }
    // 省略
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>所谓setter，就是 <strong>可以对属性赋值的方法</strong>。当我们想要改变属性的赋值逻辑时，我们就可以通过自定义来实现了。需要注意的是，以上代码当中的value，就是set方法传入的参数。而set()方法当中的field则是代表了age，这是Kotlin编译器为我们提供的字段。field = value，这一行代码就表示我们实现了对age的赋值操作。<strong>(见文件Kotlin中为什么要有field.md)</strong></p> <p>有的时候，我们不希望属性的set方法在外部访问，那么我们可以给set方法加上可见性修饰符，比如这里，我们可以给set方法加上private，限制它仅可以在类的内部访问：</p> <div class="language-plain line-numbers-mode"><pre class="language-plain"><code>class Person(val name: String) {
    var age: Int = 0
        private set(value: Int) {
            log(value)
            field = value
        }
    // 省略
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>在了解了Kotlin中类的定义以后，我们再来看一种特殊的类：抽象类。</p> <h2 id="抽象类与继承"><a href="#抽象类与继承" class="header-anchor">#</a> 抽象类与继承</h2> <p>前面我们所创建的类，比如Person，它是具体的、已经定型的类，我们可以直接用它来创建对象。而抽象类，则不是具体的类，它没有完全定型，我们也不能直接用它来创建对象。</p> <p>在Kotlin当中，抽象类的定义和Java几乎一样，也就是在关键字“class”“fun”的前面加上abstract关键字即可。这里我们继续上面的例子，把Person定义成抽象类，然后为它添加一个抽象方法：</p> <div class="language-plain line-numbers-mode"><pre class="language-plain"><code>abstract class Person(val name: String) {
    abstract fun walk()
    // 省略
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这样一来，如果我们要创建Person类，就必须要使用匿名内部类的方式，或者使用Person的子类来创建变量。而这，就需要用到 <strong>类的继承</strong> 了。</p> <p>从概念上讲，Kotlin的继承和Java的并没有区别，它们只是在语法上有一点点不一样。Java当中我们是使用extends表示继承，而Kotlin当中我们则使用冒号来表示继承。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//                      Java 的继承</span>
<span class="token comment">//                           ↓</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainActivity</span> <span class="token keyword">extends</span> <span class="token class-name">Activity</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">void</span> <span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//              Kotlin 的继承</span>
<span class="token comment">//                 ↓</span>
<span class="token keyword">class</span> <span class="token class-name">MainActivity</span> <span class="token operator">:</span> <span class="token class-name">AppCompatActivity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    override fun <span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>除了继承的语法不太一样，重写的表达方式也不太一样。Java当中是使用@Override注解，而Kotlin当中直接将其定义为了 <strong>override关键字</strong>。而除了抽象类以外，正常的类其实也是可以被继承的。不过，我们必须对这个类 <strong>标记为open</strong>。如果一个类不是抽象类，并且没有用open修饰的话，它是无法被继承的。</p> <div class="language-plain line-numbers-mode"><pre class="language-plain"><code>class Person() {
    fun walk()
}

// 报错
class Boy: Person() {
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>根据以上代码我们可以看到，Person不是抽象类，同时它也没有被open修饰。Boy这个类尝试继承Person，会导致编译器报错。所以，我们必须为Person这个类加上open关键字：</p> <div class="language-plain line-numbers-mode"><pre class="language-plain"><code>open class Person() {
    open fun walk()
}

class Boy: Person() {
    // 省略重写逻辑
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>所以，Kotlin的类，默认是不允许继承的，除非这个类明确被open关键字修饰了。另外，对于被open修饰的普通类，它内部的方法和属性，默认也是不允许重写的，除非它们也被open修饰了：</p> <div class="language-plain line-numbers-mode"><pre class="language-plain"><code>open class Person() {
    val canWalk: Boolean = false
    fun walk()
}

class Boy: Person() {
    // 报错
    override val canWalk: Boolean = true
    // 报错
    override fun walk() {
    }
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>可以看到，由于Person类当中的canWalk属性以及walk()方法，它们都没有使用open修饰，在这种情况下，即使Person可以被继承，但在继承之后的Boy类当中，我们是无法重写canWalk属性、walk()方法的。</p> <p>也就是说， <strong>在继承的行为上面，Kotlin和Java完全相反。</strong> Java当中，一个类如果没有被final明确修饰的话，它默认就是可以被继承的。而这同时也就导致了，在Java当中“继承”被过度使用。</p> <p>所以， <strong>Java的继承是默认开放的，Kotlin的继承是默认封闭的</strong>。Kotlin的这个设计非常好，这样就不会出现Java中“继承被滥用”的情况。</p> <p>好，下面，我们再来看看另一种常见的面向对象的编程方式，那就是“实现”。</p> <h2 id="接口和实现"><a href="#接口和实现" class="header-anchor">#</a> 接口和实现</h2> <p>Kotlin当中的接口（interface），和Java也是大同小异的，它们都是通过 <strong>interface</strong> 这个关键字来定义的。</p> <div class="language-plain line-numbers-mode"><pre class="language-plain"><code>interface Behavior {
    fun walk()
}

class Person(val name: String): Behavior {
    override fun walk() {
        // walk
    }
    // ...
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>可以看到在以上的代码中，我们定义了一个新的接口Behavior，它里面有一个需要被实现的方法walk，然后我们在Person类当中实现了这个接口。</p> <p>而在这里，我们又会发现Kotlin和Java不同的小细节： <strong>Kotlin的继承和接口实现语法是一样的。</strong> 多么贴心！</p> <p>Kotlin的接口，跟Java最大的差异就在于，接口的方法可以有默认实现，同时，它也可以有属性。比如，我们来看看下面这段代码：</p> <div class="language-plain line-numbers-mode"><pre class="language-plain"><code>interface Behavior {
    // 接口内的可以有属性
    val canWalk: Boolean

    // 接口方法的默认实现
    fun walk() {
        if (canWalk) {
            // do something
        }
    }
}

class Person(val name: String): Behavior {
    // 重写接口的属性
    override val canWalk: Boolean
        get() = true
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>可以看到，我们在Behavior接口当中增加了一个属性canWalk，代表是否可以行走。与此同时，我们在接口方法当中，为walk()方法提供了默认实现，这个实现的逻辑也很简单，如果canWalk为true，才执行walk内部的具体行为。</p> <p>需要特别注意的是，由于walk已经有了默认的实现，所以我们在Person类当中就可以不必实现walk方法了。而Kotlin的这一设计，就让**“接口”和“抽象类”之间的界限越来越模糊了**。</p> <p>换句话说，Kotlin当中的接口，被设计得更加强大了， <strong>它拥有了部分抽象类才有的特性，同时还可以灵活使用接口组合的特性</strong>。</p> <p>另外你还需要知道一点，就是虽然在Java 1.8版本当中，接口也引入了类似的特性，但由于Kotlin是完全兼容Java 1.6版本的。因此为了实现这个特性，Kotlin编译器在背后做了一些转换。这也就意味着，它是有一定局限性的。</p> <h2 id="嵌套"><a href="#嵌套" class="header-anchor">#</a> 嵌套</h2> <p>Java当中，最常见的嵌套类分为两种：非静态内部类、静态内部类。Kotlin当中也有一样的概念。</p> <div class="language-plain line-numbers-mode"><pre class="language-plain"><code>class A {
    class B {
    }
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>以上代码中，B类，就是A类里面的嵌套类，这非常容易理解。不过我们需要注意的是，这种写法的嵌套类，我们无法在B类当中访问A类的属性和成员方法。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class A {
    val name: String = &quot;&quot;
    fun foo() = 1

    class B {
        val a = name   // 报错
        val b = foo()  // 报错
    }
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>可以看到，当我们尝试在B类当中访问A类的成员时，编译器会报错。如果你有Java基础，应该马上就能反应过来：这种写法就对应了Java当中的静态内部类！</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 等价的Java代码如下：
public class A() {
    public String name = &quot;&quot;;
    public int foo() { return 1; }

    public static class B {
        String a = name)   // 报错
        int b = foo()      // 报错
    }
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>所以，Kotlin当中的普通嵌套类，它的本质是静态的。相应地，如果想在Kotlin当中定义一个普通的内部类，我们需要在嵌套类的前面加上 <strong>inner关键字</strong>。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class A {
    val name: String = &quot;&quot;
    fun foo() = 1
// 增加了一个关键字
//    ↓
    inner class B {
        val a = name   // 通过
        val b = foo()  // 通过
    }
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>inner关键字，代表了B类是A类内部的类，这种情况下，我们在B类的内部是可以访问A类的成员属性和方法的。</p> <p>Kotlin的这种设计非常巧妙。如果你熟悉Java开发，你会知道，Java当中的嵌套类，如果没有static关键字的话，它就是一个内部类，这样的内部类是会持有外部类的引用的。可是，这样的设计在Java当中会非常容易出现内存泄漏！而大部分Java开发者之所以会犯这样的错误，往往只是因为忘记加“static”关键字了。这是一个Java开发者默认情况下就容易犯的错。</p> <p>Kotlin则反其道而行之，在默认情况下， <strong>嵌套类变成了静态内部类</strong>，而这种情况下的嵌套类是不会持有外部类引用的。只有当我们真正需要访问外部类成员的时候，我们才会加上inner关键字。这样一来，默认情况下，开发者是不会犯错的，只有手动加上inner关键字之后，才可能会出现内存泄漏，而当我们加上inner之后，其实往往也就能够意识到内存泄漏的风险了。</p> <p>也就是说， <strong>Kotlin这样的设计，就将默认犯错的风险完全抹掉了！</strong></p> <h2 id="kotlin中的特殊类"><a href="#kotlin中的特殊类" class="header-anchor">#</a> Kotlin中的特殊类</h2> <p>好了，到目前为止，我们接触到的都是Kotlin与Java都有的概念。接下来，我们来看两个Java当中没有的概念，数据类和密封类。</p> <h3 id="数据类"><a href="#数据类" class="header-anchor">#</a> 数据类</h3> <p>数据类（Data Class），顾名思义，就是 <strong>用于存放数据的类</strong>。要定义一个数据类，我们只需要在普通的类前面加上一个关键字“data”即可。比如前面案例当中的Person类，我们只需要在它的前面加上data，就可以将它变为一个“数据类”。</p> <div class="language-plain line-numbers-mode"><pre class="language-plain"><code>    // 数据类当中，最少要有一个属性
                   ↓
data class Person(val name: String, val age: Int)

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>在Kotlin当中，编译器会为数据类自动生成一些有用的方法。它们分别是：</p> <ul><li>equals()；</li> <li>hashCode()；</li> <li>toString()；</li> <li>componentN() 函数；</li> <li>copy()。</li></ul> <p>所以，即使我们的Person类只有一行Kotlin代码，我们仍然可以在其他地方调用编译器，为我们自动生成这些方法。</p> <div class="language-plain line-numbers-mode"><pre class="language-plain"><code>val tom = Person(&quot;Tom&quot;, 18)
val jack = Person(&quot;Jack&quot;, 19)

println(tom.equals(jack)) // 输出：false
println(tom.hashCode())   // 输出：对应的hash code
println(tom.toString())   // 输出：Person(name=Tom, age=18)

val (name, age) = tom     // name=Tom, age=18
println(&quot;name is $name, age is $age .&quot;)

val mike = tom.copy(name = &quot;Mike&quot;)
println(mike)             // 输出：Person(name=Mike, age=18)

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>这里你需要注意的是最后的四行代码。</p> <p>“val (name, age) = tom”这行代码，其实是使用了数据类的解构声明。这种方式，可以让我们快速通过数据类来创建一连串的变量。另外，就是copy方法。数据类为我们默认实现了copy方法，可以让我们非常方便地在创建一份拷贝的同时，修改某个属性。</p> <h3 id="密封类"><a href="#密封类" class="header-anchor">#</a> 密封类</h3> <p>Kotlin当中的密封类，常常用来表示某种受到限制的继承结构。这样说起来可能有点抽象，让我们换个说法： <strong>密封类，是更强大的枚举类</strong>。</p> <p>首先，让我们看看枚举类是什么。</p> <div class="language-plain line-numbers-mode"><pre class="language-plain"><code>enum class Human {
    MAN, WOMAN
}

fun isMan(data: Human) = when(data) {
    Human.MAN -&gt; true
    Human.WOMAN -&gt; false
    // 这里不需要else分支，编译器自动推导出逻辑已完备
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>我们通过enum就可以定义枚举类， <strong>所谓枚举，就是一组有限的数量的值</strong>。比如，人分为男人和女人。这样的分类是有限的，所以我们可以枚举出每一种情况。我们在when表达式当中使用枚举时，编译器甚至可以自动帮我们推导出逻辑是否完备。这是枚举的优势。</p> <p>如果没有枚举，如何实现我们想要的效果呢</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token comment">//定义整型常量</span>
<span class="token keyword">const</span> <span class="token keyword">val</span> CN <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">const</span> <span class="token keyword">val</span> USA <span class="token operator">=</span> <span class="token number">2</span>

<span class="token keyword">fun</span> <span class="token function">printCountryWithInt</span><span class="token punctuation">(</span>day<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">when</span><span class="token punctuation">(</span>day<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        CN <span class="token operator">-&gt;</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;中国&quot;</span></span><span class="token punctuation">)</span>
        USA <span class="token operator">-&gt;</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;美国&quot;</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">printCountryWithInt</span><span class="token punctuation">(</span>CN<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>但上述实现无法控制传入的类型，可以传入1,2以外的值，类型不安全。那么该怎么办呢</p> <p>将整型常量用类代替，使用<strong>工厂模式</strong>（见文件Kotlin中的object.md）</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token comment">// 这就是枚举的雏形↓</span>
<span class="token keyword">class</span> Country2 <span class="token keyword">private</span> <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">companion</span> <span class="token keyword">object</span> <span class="token punctuation">{</span>
        <span class="token keyword">val</span> CN <span class="token operator">=</span> <span class="token function">Country2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">val</span> USA <span class="token operator">=</span> <span class="token function">Country2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token keyword">fun</span> <span class="token function">printCountryWithInt</span><span class="token punctuation">(</span>country<span class="token operator">:</span> Country2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">when</span><span class="token punctuation">(</span>country<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        CN <span class="token operator">-&gt;</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;中国&quot;</span></span><span class="token punctuation">)</span>
        USA <span class="token operator">-&gt;</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;美国&quot;</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">printCountryWithClass</span><span class="token punctuation">(</span>Country2<span class="token punctuation">.</span>CN<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>枚举可以简单理解为对Country2这种类的封装。</p> <p>when 表达式非常适合与枚举类一起使用。当你需要根据某个条件处理不同的枚举常量时，使用 when 表达式可以更清晰地表达你的意图</p> <p>枚举类也可以具有成员</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token comment">//可以定义成员变量，但是不能命名为name，因为name拿来返回枚举名称了</span>
<span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token function">LightState</span><span class="token punctuation">(</span><span class="token keyword">val</span> color<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">GREEN</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;绿灯&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">YELLOW</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;黄灯&quot;</span></span><span class="token punctuation">)</span>，
    <span class="token function">RED</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;红灯&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 枚举在定义时也必须填写参数，如果后面还要编写成员函数之类的其他内容，还需在末尾添加分号结束</span>
    
    <span class="token keyword">fun</span> <span class="token function">isGreen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">this</span> <span class="token operator">==</span> LightState<span class="token punctuation">.</span>GREEN <span class="token comment">// 定义一个函数也是没问题的</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>下面有一个很好的例子</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token function">Direction</span><span class="token punctuation">(</span><span class="token keyword">var</span> direction<span class="token operator">:</span> String<span class="token punctuation">,</span> <span class="token keyword">var</span> distance<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">NORTH</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;north&quot;</span></span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">SOUTH</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;south&quot;</span></span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">EAST</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;east&quot;</span></span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">WEST</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;west&quot;</span></span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">fun</span> <span class="token function">printData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Direction =</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">direction</span></span><span class="token string"> and Distance =</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">distance</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">println</span><span class="token punctuation">(</span>Direction<span class="token punctuation">.</span>NORTH<span class="token punctuation">.</span>direction<span class="token punctuation">)</span> <span class="token comment">// north</span>
    <span class="token function">println</span><span class="token punctuation">(</span>Direction<span class="token punctuation">.</span>NORTH<span class="token punctuation">.</span>distance<span class="token punctuation">)</span> <span class="token comment">// 10</span>
    <span class="token function">println</span><span class="token punctuation">(</span>Direction<span class="token punctuation">.</span>NORTH<span class="token punctuation">.</span>name<span class="token punctuation">)</span>     <span class="token comment">// NORTH</span>

    Direction<span class="token punctuation">.</span>WEST<span class="token punctuation">.</span><span class="token function">printData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>还有一个例子</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token function">PaymentRtnCode</span><span class="token punctuation">(</span><span class="token keyword">var</span> type<span class="token operator">:</span> String<span class="token punctuation">,</span> <span class="token keyword">var</span> code<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">RC2</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;token 错误&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">&quot;2&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">RC1</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;系统维护中&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">&quot;1&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">RCN4</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;无此账户&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">&quot;-4&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">C0</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;有未缴费用&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">&quot;0&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">companion</span> <span class="token keyword">object</span> <span class="token punctuation">{</span>
        <span class="token keyword">fun</span> <span class="token function">getType</span><span class="token punctuation">(</span>code<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span>b <span class="token keyword">in</span> <span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token punctuation">.</span>code <span class="token operator">==</span> code<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">return</span> b<span class="token punctuation">.</span>type
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token string-literal singleline"><span class="token string">&quot;未知的原因&quot;</span></span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>但枚举类型是有一些局限性的</p> <p>枚举的局限性</p> <ul><li>限制枚举每个类型只允许有一个实例</li> <li>限制所有枚举常量使用相同的类型的值</li></ul> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token function">Color</span><span class="token punctuation">(</span><span class="token keyword">val</span> value<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">Red</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> red1 <span class="token operator">=</span> Color<span class="token punctuation">.</span>Red
    <span class="token keyword">val</span> red2 <span class="token operator">=</span> Color<span class="token punctuation">.</span>Red
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token expression">red1 <span class="token operator">==</span> red2</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span> <span class="token comment">// true</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>正如你看到的，我们定义了一个单元素的枚举类型，无论 Color.Red 有多少个对象，最终他们的实例都是一个，每个枚举常量仅作为一个实例存在</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token function">Color</span><span class="token punctuation">(</span><span class="token keyword">val</span> value<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">Red</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">Green</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">Blue</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>正如你所见，我们在枚举 Color 中定义了三个常量 Red 、Green 、Blue，但是它们只能使用 Int 类型的值，不能使用其他类型的值，如果使用其它类型的值会怎么样？如下所示：</p> <p><img src="https://cdn.jsdelivr.net/gh/saukaguya/tu/image/image-20240313231438389.png" alt="image-20240313231438389"></p> <p>编译器会告诉你只接受 Int 类型的值，无法更改它的类型，也就是说你无法为枚举类型，添加额外的信息。</p> <p>Sealed Class就是为了解决上述问题</p> <p><strong>Sealed Class用于表示受限制的类层次结构</strong>。</p> <p>其实这句话可以拆成两句话来理解</p> <ul><li>Sealed Class用于表示层级关系：子类可以是任意的类，数据类、kotlin对象、普通的类，甚至也可以是另一个Sealed</li> <li>Sealed Class受限制：必须在同一文件中，或者在Sealed Class类的内部中使用</li></ul> <p>其实对密封类与枚举的区别已经表达的很明确了，对比来说就是：</p> <ol><li>枚举类每种类型只允许有一个实例，而密封类可以有多个</li> <li>枚举所有常量值类型必须相同，而密封类可以是多种</li></ol> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token function">Color</span><span class="token punctuation">(</span><span class="token keyword">val</span> value<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">RED</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">BLUE</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">GREEN</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">sealed</span> <span class="token keyword">class</span> Expr

<span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">Const</span><span class="token punctuation">(</span><span class="token keyword">val</span> number<span class="token operator">:</span> Double<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Expr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">Text</span><span class="token punctuation">(</span><span class="token keyword">val</span> content<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Expr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">Sum</span><span class="token punctuation">(</span><span class="token keyword">val</span> e1<span class="token operator">:</span> Expr<span class="token punctuation">,</span> <span class="token keyword">val</span> e2<span class="token operator">:</span> Expr<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Expr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">object</span> NotANumber <span class="token operator">:</span> <span class="token function">Expr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> red1 <span class="token operator">=</span> Color<span class="token punctuation">.</span>RED
    <span class="token keyword">val</span> red2 <span class="token operator">=</span> Color<span class="token punctuation">.</span>RED
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token expression">red1 <span class="token operator">==</span> red2</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span> <span class="token comment">// true</span>

    <span class="token keyword">val</span> const1 <span class="token operator">=</span> <span class="token function">Const</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span>
    <span class="token keyword">val</span> const2 <span class="token operator">=</span> <span class="token function">Const</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token expression">const1 <span class="token operator">==</span> const2</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span> <span class="token comment">// false</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>在Android开发当中，我们会经常使用密封类对数据进行封装。比如我们可以来看一个代码例子：</p> <div class="language-plain line-numbers-mode"><pre class="language-plain"><code>sealed class Result&lt;out R&gt; {
    data class Success&lt;out T&gt;(val data: T, val message: String = &quot;&quot;) : Result&lt;T&gt;()

    data class Error(val exception: Exception) : Result&lt;Nothing&gt;()

    data class Loading(val time: Long = System.currentTimeMillis()) : Result&lt;Nothing&gt;()
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>首先，我们使用sealed关键字定义了一个Result类，并且它需要一个泛型参数R，R前面的out我们可以暂时先忽略。</p> <p>这个密封类，我们是专门用于封装网络请求结果的。可以看到，在Result类当中，分别有三个数据类，分别是Success、Error、Loading。我们将一个网络请求结果也分为了三大类，分别代表请求成功、请求失败、请求中。</p> <p>这样，当网络请求有结果以后，我们的UI展示逻辑就会变得非常简单，也就是非常直白的三个逻辑分支：成功、失败、进行中。我们将其与Kotlin协程当中的when表达式相结合，就能很好地处理UI展示逻辑：如果是Loading，我们就展示进度条；如果是Success，我们就展示成功的数据；如果是Error，我们就展示错误提示框。</p> <div class="language-plain line-numbers-mode"><pre class="language-plain"><code>fun display(data: Result) = when(data) {
    is Result.Success -&gt; displaySuccessUI(data)
    is Result.Error -&gt; showErrorMsg(data)
    is Result.Loading -&gt; showLoading()
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>由于我们的密封类只有这三种情况，所以我们的when表达式不需要else分支。可以看到，这样的代码风格，既实现了类似枚举类的逻辑完备性，还完美实现了数据结构的封装。</p> <p>而且，在最新的Kotlin 1.5 版本当中，sealed不仅仅可以用于修饰类，还可以用于修饰接口。这就为我们的密封类实现多个接口，提供了可能。</p> <h2 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h2> <p>在这节课当中，我们学习了面向对象常见的概念，包括类、继承、接口、实现、枚举，还有Kotlin独有的数据类、密封类。同时也进一步领略到了Kotlin语法在一些细节的良苦用心。比如说：</p> <ul><li>Kotlin的类，默认是public的。</li> <li>Kotlin的类继承语法、接口实现语法，是完全一样的。</li> <li>Kotlin当中的类默认是对继承封闭的，类当中的成员和方法，默认也是无法被重写的。这样的设计就很好地避免了继承被滥用。</li> <li>Kotlin接口可以有成员属性，还可以有默认实现。</li> <li>Kotlin的嵌套类默认是静态的，这种设计可以防止我们无意中出现内存泄漏问题。</li> <li>Kotlin独特的数据类，在语法简洁的同时，还给我们提供了丰富的功能。</li> <li>密封类，作为枚举和对象的结合体，帮助我们很好地设计数据模型，支持when表达式完备性。</li></ul> <p>看到这里，你一定会发现，我们上面提到的这些点，正好也是决定着Kotlin编程思想的关键。也正是Kotlin这样独特的设计，才形成了Kotlin迥然不同的编程风格。</p> <p>“如何才能拥有Kotlin编程思维，而不是用Kotlin写Java风格代码？如何才能写出优雅的Kotlin代码？”</p> <p>答案其实很简单，我们先要掌握Kotlin的语法，然后透过这些语法细节去揣摩Kotlin设计者的意图，当我们理解Kotlin设计者为什么要设计某个语法时，我们就不可能用错这个语法了。而当我们能够用好Kotlin的每个语法的时候，我们自然而然地就可以写出优雅的Kotlin代码了。</p> <p>比如，当我们知道数据类是为了解决冗余的Java Bean而设计的，那我们无论如何都不会在Kotlin当中再写一遍Kotlin Bean了。又或者，当我们知道when表达式可以自动判断逻辑分支是否完备的时候，我们自然就会想办法让when与枚举类/密封类结合使用了。</p></div></div> <!----> <div class="page-edit"><div class="edit-link"><a href="https://github.com/saukaguya/blog/edit/main/docs/01.one/02.面向对象：理解Kotlin设计者的良苦用心.md" target="_blank" rel="noopener noreferrer">帮助我们改善此页面</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2024/06/12, 00:04:55</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/blog/pages/9f74b6/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">Kotlin基础语法：正式开启学习之旅</div></a> <a href="/blog/pages/31d2bd/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">Kotlin中的object</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/blog/pages/9f74b6/" class="prev">Kotlin基础语法：正式开启学习之旅</a></span> <span class="next"><a href="/blog/pages/31d2bd/">Kotlin中的object</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="https://github.com/saukaguya" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="saukaguya0101@gmail.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://gitee.com/saukaguya" title="Gitee" target="_blank" class="iconfont icon-gitee"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2024-2024
    <span>Eryajf | <a href="https://github.com/eryajf/blog/blob/main/LICENSE" target="_blank">MIT License</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><!----></div></div>
    <script src="/blog/assets/js/app.0eb42f52.js" defer></script><script src="/blog/assets/js/2.409f7334.js" defer></script><script src="/blog/assets/js/9.ed0bb6e8.js" defer></script>
  </body>
</html>
