<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Kotlin基础语法：正式开启学习之旅 | blog</title>
    <meta name="generator" content="VuePress 1.8.0">
    <link rel="icon" href="https://cdn.jsdelivr.net/gh/eryajf/tu/img/image_20220720_132133.ico">
    <script language="javascript" type="text/javascript" src="/blog/js/pgmanor-self.js"></script>
    <meta name="description" content="vdoing博客主题模板">
    <meta name="keywords" content="二丫讲梵,golang,vue,go-web,go-admin,go-ldap-admin">
    <meta name="theme-color" content="#11a8cd">
    <meta name="referrer" content="no-referrer-when-downgrade">
    
    <link rel="preload" href="/blog/assets/css/0.styles.431af8fc.css" as="style"><link rel="preload" href="/blog/assets/js/app.b4e5127e.js" as="script"><link rel="preload" href="/blog/assets/js/2.1e7fad39.js" as="script"><link rel="preload" href="/blog/assets/js/8.a42f8812.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.573a6ce4.js"><link rel="prefetch" href="/blog/assets/js/11.88950b0b.js"><link rel="prefetch" href="/blog/assets/js/12.b65e2ff1.js"><link rel="prefetch" href="/blog/assets/js/13.b3631d8c.js"><link rel="prefetch" href="/blog/assets/js/14.e4d8064a.js"><link rel="prefetch" href="/blog/assets/js/3.c04d6d19.js"><link rel="prefetch" href="/blog/assets/js/4.a1d398bc.js"><link rel="prefetch" href="/blog/assets/js/5.18d9eb71.js"><link rel="prefetch" href="/blog/assets/js/6.ba3ff270.js"><link rel="prefetch" href="/blog/assets/js/7.acf25039.js"><link rel="prefetch" href="/blog/assets/js/9.3fcc521d.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.431af8fc.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="https://cdn.jsdelivr.net/gh/eryajf/tu/img/image_20220720_132208.png" alt="blog" class="logo"> <span class="site-name can-hide">blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">首页</a></div><div class="nav-item"><a href="/blog/one/" class="nav-link">编程</a></div><div class="nav-item"><a href="/blog/two/" class="nav-link">杂谈</a></div><div class="nav-item"><a href="/blog/three/" class="nav-link">运维</a></div><div class="nav-item"><a href="/blog/message-board/" class="nav-link">留言板</a></div> <a href="https://github.com/saukaguya/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">首页</a></div><div class="nav-item"><a href="/blog/one/" class="nav-link">编程</a></div><div class="nav-item"><a href="/blog/two/" class="nav-link">杂谈</a></div><div class="nav-item"><a href="/blog/three/" class="nav-link">运维</a></div><div class="nav-item"><a href="/blog/message-board/" class="nav-link">留言板</a></div> <a href="https://github.com/saukaguya/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/blog/pages/7cf1c8/" aria-current="page" class="active sidebar-link">Kotlin基础语法：正式开启学习之旅</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/blog/pages/7cf1c8/#开发环境" class="sidebar-link">开发环境</a></li><li class="sidebar-sub-header level2"><a href="/blog/pages/7cf1c8/#变量" class="sidebar-link">变量</a></li><li class="sidebar-sub-header level2"><a href="/blog/pages/7cf1c8/#基础类型" class="sidebar-link">基础类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/blog/pages/7cf1c8/#一切都是对象" class="sidebar-link">一切都是对象</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/7cf1c8/#空安全" class="sidebar-link">空安全</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/7cf1c8/#数字类型" class="sidebar-link">数字类型</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/7cf1c8/#布尔类型" class="sidebar-link">布尔类型</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/7cf1c8/#字符-char" class="sidebar-link">字符：Char</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/7cf1c8/#字符串-string" class="sidebar-link">字符串：String</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/7cf1c8/#数组" class="sidebar-link">数组</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/blog/pages/7cf1c8/#函数声明" class="sidebar-link">函数声明</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/blog/pages/7cf1c8/#函数调用" class="sidebar-link">函数调用</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/blog/pages/7cf1c8/#流程控制" class="sidebar-link">流程控制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/blog/pages/7cf1c8/#if" class="sidebar-link">if</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/7cf1c8/#when" class="sidebar-link">when</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/7cf1c8/#循环迭代-while与for" class="sidebar-link">循环迭代：while与for</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/blog/pages/7cf1c8/#小结" class="sidebar-link">小结</a></li></ul></li><li><a href="/blog/pages/9424ea/" class="sidebar-link">面向对象：理解Kotlin设计者的良苦用心</a></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/blog/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/blog/one/#one" data-v-06225672>one</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/saukaguya" target="_blank" title="作者" class="beLink" data-v-06225672>Suakaguya</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2024-06-11</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">Kotlin基础语法：正式开启学习之旅<!----></h1> <!----> <div class="theme-vdoing-content content__default"><h1 id="_01-kotlin基础语法-正式开启学习之旅"><a href="#_01-kotlin基础语法-正式开启学习之旅" class="header-anchor">#</a> 01 | Kotlin基础语法：正式开启学习之旅</h1> <h2 id="开发环境"><a href="#开发环境" class="header-anchor">#</a> 开发环境</h2> <p>在正式开始学习基础语法之前，我们还需要配置一下Kotlin语言的环境，因为直接从代码开始学能给我们带来最直观的体验。</p> <p>那么要运行Kotlin代码，最快的方式，就是 <strong>使用Kotlin官方的</strong> <a href="https://play.kotlinlang.org/" target="_blank" rel="noopener noreferrer">PlayGround<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。通过这个在线工具，我们可以非常方便地运行Kotlin代码片段。当然，这种方式用来临时测试一小段代码是没有问题的，但对于复杂的工程就有些力不从心了。</p> <p>另一种方式，<strong>安装</strong> <a href="https://www.jetbrains.com/idea/download/" target="_blank" rel="noopener noreferrer">IntelliJ IDEA<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <h2 id="变量"><a href="#变量" class="header-anchor">#</a> 变量</h2> <p>在Java/C当中，如果我们要声明变量，我们必须要声明它的类型，后面跟着变量的名称和对应的值，然后以分号结尾。就像这样：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Integer</span> price <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>而Kotlin则不一样，我们要使用“ <strong>val</strong>”或者是“ <strong>var</strong>”这样的关键字作为开头，后面跟“变量名称”，接着是“变量类型”和“赋值语句”，最后是分号结尾。就像这样：</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token comment">/*
关键字     变量类型
 ↓          ↓           */</span>
<span class="token keyword">var</span> price<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>   <span class="token comment">/*
     ↑            ↑
   变量名        变量值   */</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>不过，像Java那样每写一行代码就写一个分号，其实也挺麻烦的。所以为了省事，在Kotlin里面，我们一般会把代码末尾的分号省略，就像这样：</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">var</span> price<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">100</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>另外，由于Kotlin支持 <strong>类型推导</strong>，大部分情况下，我们的变量类型可以省略不写，就像这样：</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">var</span> price <span class="token operator">=</span> <span class="token number">100</span> <span class="token comment">// 默认推导类型为： Int</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>还有一点我们要注意，就是在Kotlin当中，我们应该尽可能避免使用var， <strong>尽可能多地去使用val</strong>。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">var</span> price <span class="token operator">=</span> <span class="token number">100</span>
price <span class="token operator">=</span> <span class="token number">101</span>

<span class="token keyword">val</span> i <span class="token operator">=</span> <span class="token number">0</span>
i <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">// 编译器报错</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>原因其实很简单：</p> <ul><li>val声明的变量，我们叫做 <strong>不可变变量</strong>，它的值在初始化以后就无法再次被修改，它相当于Java里面的final变量。</li> <li>var声明的变量，我们叫做 <strong>可变变量</strong>，它对应Java里的普通变量。</li></ul> <p>更值得注意的是，绝大多数教程都没有提到的，<strong>val没有对存储的对象施加任何额外的限制，是一个不可变的引用，没有说明存储的内容</strong></p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">val</span> languages <span class="token operator">=</span> <span class="token function">mutableListOf</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Java&quot;</span></span><span class="token punctuation">)</span>
languages<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;kotlin&quot;</span></span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="基础类型"><a href="#基础类型" class="header-anchor">#</a> 基础类型</h2> <p>了解了变量类型如何声明之后，我们再来看下Kotlin中的基础类型。</p> <p>基础类型，包括我们常见的数字类型、布尔类型、字符类型，以及前面这些类型组成的数组。这些类型是我们经常会遇到的概念，因此我们把它统一归为“基础类型”。</p> <h3 id="一切都是对象"><a href="#一切都是对象" class="header-anchor">#</a> 一切都是对象</h3> <p>在Java里面，基础类型分为原始类型（Primitive Types）和包装类型（Wrapper Type）。比如，整型会有对应的int和Integer，前者是原始类型，后者是包装类型。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 原始类型</span>
<span class="token class-name">Integer</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 包装类型</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Java之所以要这样做，是因为原始类型的开销小、性能高，但它不是对象，无法很好地融入到面向对象的系统中。而包装类型的开销大、性能相对较差，但它是对象，可以很好地发挥面向对象的特性。在 <a href="https://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/lang/Integer.java" target="_blank" rel="noopener noreferrer">JDK源码<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 当中，我们可以看到Integer作为包装类型，它是有成员变量以及成员方法的，这就是它作为对象的优势。</p> <p>然而，在Kotlin语言体系当中，是没有原始类型这个概念的。这也就意味着， <strong>在Kotlin里，一切都是对象。</strong></p> <p>实际上，从某种程度上讲，Java的类型系统并不是完全面向对象的，因为它存在原始类型，而原始类型并不属于对象。而Kotlin则不一样，它从语言设计的层面上就规避了这个问题，类型系统则是完全面向对象的。</p> <p>我们看一段代码，来更直观地感受Kotlin的独特之处：</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">val</span> i<span class="token operator">:</span> Double <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">.</span><span class="token function">toDouble</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>可以发现，由于在Kotlin中，整型数字“1”被看作是对象了，所以我们可以调用它的成员方法toDouble()，而这样的代码在Java中是无法实现的。</p> <h3 id="空安全"><a href="#空安全" class="header-anchor">#</a> 空安全</h3> <p>既然Kotlin中的一切都是对象，那么对象就有可能为空。也许你会想到写这样的代码：</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">val</span> i<span class="token operator">:</span> Double <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment">// 编译器报错</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>可事实上，以上的代码并不能通过Kotlin编译。这是因为Kotlin强制要求开发者 <strong>在定义变量的时候，指定这个变量是否可能为null</strong>。对于可能为null的变量，我们需要在声明的时候，在变量类型后面加一个问号“?”：</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">val</span> i<span class="token operator">:</span> Double <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment">// 编译器报错</span>
<span class="token keyword">val</span> j<span class="token operator">:</span> Double<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment">// 编译通过</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>并且由于Kotlin对可能为空的变量类型做了强制区分，这就意味着，“可能为空的变量”无法直接赋值给“不可为空的变量”，当然，反向赋值是没有问题的。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">var</span> i<span class="token operator">:</span> Double <span class="token operator">=</span> <span class="token number">1.0</span>
<span class="token keyword">var</span> j<span class="token operator">:</span> Double<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span>

i <span class="token operator">=</span> j  <span class="token comment">// 编译器报错</span>
j <span class="token operator">=</span> i  <span class="token comment">// 编译通过</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Kotlin这么设计的原因也很简单，如果我们将“可能为空的变量”直接赋值给了“不可为空的变量”，这会跟它自身的定义产生冲突。而如果我们实在有这样的需求，也不难实现，只要做个判断即可：</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">var</span> i<span class="token operator">:</span> Double <span class="token operator">=</span> <span class="token number">1.0</span>
<span class="token keyword">val</span> j<span class="token operator">:</span> Double<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    i <span class="token operator">=</span> j  <span class="token comment">// 编译通过</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="数字类型"><a href="#数字类型" class="header-anchor">#</a> 数字类型</h3> <p>首先，在数字类型上，Kotlin和Java几乎是一致的，包括它们对数字“字面量”的定义方式。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">val</span> int <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">val</span> long <span class="token operator">=</span> <span class="token number">1234567L</span>
<span class="token keyword">val</span> double <span class="token operator">=</span> <span class="token number">13.14</span>
<span class="token keyword">val</span> float <span class="token operator">=</span> <span class="token number">13.14F</span>
<span class="token keyword">val</span> hexadecimal <span class="token operator">=</span> <span class="token number">0xAF</span>
<span class="token keyword">val</span> binary <span class="token operator">=</span> <span class="token number">0b01010101</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这里我也来给你具体介绍下：</p> <ul><li>整数默认会被推导为“Int”类型；</li> <li>Long类型，我们则需要使用“L”后缀；</li> <li>小数默认会被推导为“Double”，我们不需要使用“D”后缀；</li> <li>Float类型，我们需要使用“F”后缀；</li> <li>使用“0x”，来代表十六进制字面量；</li> <li>使用“0b”，来代表二进制字面量。</li></ul> <p>但是，对于数字类型的转换，Kotlin与Java的转换行为是不一样的。 <strong>Java可以隐式转换数字类型，而Kotlin更推崇显式转换。在Kotlin中，没有隐式转换</strong></p> <p>举个简单的例子，在Java和C当中，我们经常直接把int类型赋值给long类型，编译器会自动为我们做类型转换，如下所示：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">long</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这段代码按照Java的编程思维方式来看，的确好像是OK的。但是你要注意，虽然Java编译器不会报错，可它仍然可能会带来问题，因为它们本质上不是一个类型，int、long、float、double这些类型之间的互相转换是存在精度问题的。尤其是当这样的代码掺杂在复杂的逻辑中时，在碰到一些边界条件的情况下，即使出现了Bug也不容易排查出来。</p> <p>所以，同样的代码，在Kotlin当中是行不通的：</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">val</span> i <span class="token operator">=</span> <span class="token number">100</span>
<span class="token keyword">val</span> j<span class="token operator">:</span> Long <span class="token operator">=</span> i <span class="token comment">// 编译器报错</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在Kotlin里，这样的隐式转换被抛弃了。正确的做法应该是显式调用Int类型的toLong()函数：</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">val</span> i <span class="token operator">=</span> <span class="token number">100</span>
<span class="token keyword">val</span> j<span class="token operator">:</span> Long <span class="token operator">=</span> i<span class="token punctuation">.</span><span class="token function">toLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 编译通过</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>其实，如果我们仔细翻看Kotlin的源代码，会发现更多类似的函数，比如toByte()、toShort()、toInt()、toLong()、toFloat()、toDouble()、toChar()等等。Kotlin这样设计的优势也是显而易见的， <strong>我们代码的可读性更强了，将来也更容易维护了</strong>。</p> <h3 id="布尔类型"><a href="#布尔类型" class="header-anchor">#</a> 布尔类型</h3> <p>无需过多解释</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">val</span> i <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">val</span> j <span class="token operator">=</span> <span class="token number">2</span>
<span class="token keyword">val</span> k <span class="token operator">=</span> <span class="token number">3</span>

<span class="token keyword">val</span> isTrue<span class="token operator">:</span> Boolean <span class="token operator">=</span> i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> k

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="字符-char"><a href="#字符-char" class="header-anchor">#</a> 字符：Char</h3> <p>Char用于代表单个的字符，比如 <code>'A'</code>、 <code>'B'</code>、 <code>'C'</code>，字符应该用单引号括起来。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">val</span> c<span class="token operator">:</span> Char <span class="token operator">=</span> <span class="token char">'A'</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>如果你有Java或C的使用经验，也许会写出这样的代码：</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">val</span> c<span class="token operator">:</span> Char <span class="token operator">=</span> <span class="token char">'A'</span>
<span class="token keyword">val</span> i<span class="token operator">:</span> Int <span class="token operator">=</span> c <span class="token comment">// 编译器报错</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这个问题其实跟前面Java的数字类型隐式转换的问题类似，所以针对这种情况，我们应该调用对应的函数来做类型转换。这一点我们一定要牢记在心。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">val</span> c<span class="token operator">:</span> Char <span class="token operator">=</span> <span class="token char">'A'</span>
<span class="token keyword">val</span> i<span class="token operator">:</span> Int <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 编译通过</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="字符串-string"><a href="#字符串-string" class="header-anchor">#</a> 字符串：String</h3> <p>字符串（String），顾名思义，就是一连串的字符。和Java一样，Kotlin中的字符串也是不可变的。在大部分情况下，我们会使用双引号来表示字符串的字面量，这一点跟Java也是一样的。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">val</span> s <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">&quot;Hello Kotlin!&quot;</span></span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>不过与此同时，Kotlin还为我们提供了非常简洁的 <strong>字符串模板</strong>：</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">val</span> name <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">&quot;Kotlin&quot;</span></span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Hello </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">name</span></span><span class="token string">!&quot;</span></span><span class="token punctuation">)</span>
<span class="token comment">/*            ↑
    直接在字符串中访问变量
*/</span>
<span class="token comment">// 输出结果：</span>
Hello Kotlin<span class="token operator">!</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这样的特性，在Java当中是没有的，这是Kotlin提供的新特性。虽然说这个字符串模板功能，我们用Java也同样可以实现，但它远没有Kotlin这么简洁。在Java当中，我们必须使用两个“+”进行拼接，比如说 <code>(&quot;Hello&quot; + name + &quot;!&quot;)</code>。这样一来，在字符串格式更复杂的情况下，代码就会很臃肿。</p> <p>当然，如果我们需要在字符串当中引用更加复杂的变量，则需要使用花括号将变量括起来：</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">val</span> array <span class="token operator">=</span> <span class="token function">arrayOf</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Java&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">&quot;Kotlin&quot;</span></span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Hello </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token expression">array<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">!&quot;</span></span><span class="token punctuation">)</span>
<span class="token comment">/*            ↑
      复杂的变量，使用${}
*/</span>
<span class="token comment">// 输出结果：</span>
Hello Kotlin<span class="token operator">!</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>另外，Kotlin还新增了一个 <strong>原始字符串</strong>，是用三个引号来表示的。它可以用于存放复杂的多行文本，并且它定义的时候是什么格式，最终打印也会是对应的格式。所以当我们需要复杂文本的时候，就不需要像Java那样写一堆的加号和换行符了。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">val</span> s <span class="token operator">=</span> <span class="token string-literal multiline"><span class="token string">&quot;&quot;&quot;
       当我们的字符串有复杂的格式时
       原始字符串非常的方便
       因为它可以做到所见即所得。 &quot;&quot;&quot;</span></span>

<span class="token function">print</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="数组"><a href="#数组" class="header-anchor">#</a> 数组</h3> <p>最后，我们再来看看Kotlin中数组的一些改变。</p> <p>在Kotlin当中，我们一般会使用 <strong>arrayOf()</strong> 来创建数组，括号当中可以用于传递数组元素进行初始化，同时，Kotlin编译器也会根据传入的参数进行类型推导。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">val</span> arrayInt <span class="token operator">=</span> <span class="token function">arrayOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token keyword">val</span> arrayString <span class="token operator">=</span> <span class="token function">arrayOf</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;apple&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">&quot;pear&quot;</span></span><span class="token punctuation">)</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>比如说，针对这里的arrayInt，由于我们赋值的时候传入了整数，所以它的类型会被推导为整型数组；对于arrayString，它的类型会被推导为字符串数组。</p> <p>而你应该也知道，在Java当中，数组和其他集合的操作是不一样的。举个例子，如果要获取数组的长度，Java中应该使用“array.length”；但如果是获取List的大小，那么Java中则应该使用“list.size”。这主要是因为数组不属于Java集合。</p> <p>不过，Kotlin在这个问题的处理上并不一样。 <strong>虽然Kotlin的数组仍然不属于集合，但它的一些操作是跟集合统一的。</strong></p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">val</span> array <span class="token operator">=</span> <span class="token function">arrayOf</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;apple&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">&quot;pear&quot;</span></span><span class="token punctuation">)</span>
<span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Size is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token expression">array<span class="token punctuation">.</span>size</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
<span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;First element is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token expression">array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span></span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>

<span class="token comment">// 输出结果：</span>
Size <span class="token keyword">is</span> <span class="token number">2</span>
First element <span class="token keyword">is</span> apple

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>就比如说，以上代码中，我们直接使用array.size就能拿到数组的长度。</p> <h2 id="函数声明"><a href="#函数声明" class="header-anchor">#</a> 函数声明</h2> <p>好，了解了Kotlin中变量和基础类型的相关概念之后，我们再来看看它的函数是如何定义的。</p> <p>在Kotlin当中，函数的声明与Java不太一样，让我们看一段简单的Kotlin代码：</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token comment">/*
关键字    函数名          参数类型   返回值类型
 ↓        ↓                ↓       ↓      */</span>
<span class="token keyword">fun</span> <span class="token function">helloFunction</span><span class="token punctuation">(</span>name<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string-literal singleline"><span class="token string">&quot;Hello </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">name</span></span><span class="token string"> !&quot;</span></span>
<span class="token punctuation">}</span><span class="token comment">/*   ↑
   花括号内为：函数体
*/</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>可以看到，在这段代码中：</p> <ul><li>使用了 <strong>fun关键字</strong> 来定义函数；</li> <li><strong>函数名称</strong>，使用的是 <a href="https://zh.wikipedia.org/zh/%E9%A7%9D%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%AF%AB" target="_blank" rel="noopener noreferrer">驼峰命名法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>（大部分情况下）；</li> <li><strong>函数参数</strong>，是以(name: String)这样的形式传递的，这代表了参数类型为String类型；</li> <li><strong>返回值类型</strong>，紧跟在参数的后面；</li> <li>最后是 <strong>花括号内的函数体</strong>，它代表了整个函数的逻辑。</li></ul> <p>另外你可以再注意一个地方，前面代码中的helloFunction函数，它的函数体实际上只有一行代码。那么针对这种情况，我们其实就可以省略函数体的花括号，直接使用“=”来连接，将其变成一种类似变量赋值的函数形式：</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">fun</span> <span class="token function">helloFunction</span><span class="token punctuation">(</span>name<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">&quot;Hello </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">name</span></span><span class="token string"> !&quot;</span></span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这种写法，我们称之为 <strong>单一表达式函数</strong>。需要注意的是，在这种情况下，表达式当中的“return”是需要去掉的。</p> <p>另外，由于Kotlin支持类型推导，我们在使用单一表达式形式的时候，返回值的类型也可以省略：</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">fun</span> <span class="token function">helloFunction</span><span class="token punctuation">(</span>name<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">&quot;Hello </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">name</span></span><span class="token string"> !&quot;</span></span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>看到这里，你一定能体会到Kotlin的魅力。它的语法非常得简洁，并且是符合人类的阅读直觉的，我们读这样的代码，就跟读自然语言一样轻松。</p> <p>然而，Kotlin的优势不仅仅体现在函数声明上，在函数调用的地方，它也有很多独到之处。</p> <h3 id="函数调用"><a href="#函数调用" class="header-anchor">#</a> 函数调用</h3> <p>以我们前面定义的函数为例子，如果我们想要调用它，代码的风格和Java基本一致：</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token function">helloFunction</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Kotlin&quot;</span></span><span class="token punctuation">)</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>不过，Kotlin提供了一些新的特性，那就是 <strong>命名参数</strong>。简单理解，就是它允许我们在调用函数的时候传入“形参的名字”。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token function">helloFunction</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">&quot;Kotlin&quot;</span></span><span class="token punctuation">)</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>让我们看一个更具体的使用场景：</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">fun</span> <span class="token function">createUser</span><span class="token punctuation">(</span>
    name<span class="token operator">:</span> String<span class="token punctuation">,</span>
    age<span class="token operator">:</span> Int<span class="token punctuation">,</span>
    gender<span class="token operator">:</span> Int<span class="token punctuation">,</span>
    friendCount<span class="token operator">:</span> Int<span class="token punctuation">,</span>
    feedCount<span class="token operator">:</span> Int<span class="token punctuation">,</span>
    likeCount<span class="token operator">:</span> Long<span class="token punctuation">,</span>
    commentCount<span class="token operator">:</span> Int
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//..</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>这是一个包含了很多参数的函数，在Kotlin当中，针对参数较多的函数，我们一般会 <strong>以纵向的方式排列</strong>，这样的代码更符合我们从上到下的阅读习惯，省去从左往右翻的麻烦。</p> <p>但是，如果我们像Java那样调用createUser，代码就会非常难以阅读：</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token function">createUser</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Tom&quot;</span></span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">78</span><span class="token punctuation">,</span> <span class="token number">2093</span><span class="token punctuation">,</span> <span class="token number">10937</span><span class="token punctuation">,</span> <span class="token number">3285</span><span class="token punctuation">)</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这里代码中的第一个参数，我们知道肯定是name，但是到了后面那一堆的数字，就会让人迷惑了。这样的代码不仅难懂，同时还不好维护。</p> <p>但如果我们这样写呢？</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token function">createUser</span><span class="token punctuation">(</span>
    name <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">&quot;Tom&quot;</span></span><span class="token punctuation">,</span>
    age <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">,</span>
    gender <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
    friendCount <span class="token operator">=</span> <span class="token number">78</span><span class="token punctuation">,</span>
    feedCount <span class="token operator">=</span> <span class="token number">2093</span><span class="token punctuation">,</span>
    likeCount <span class="token operator">=</span> <span class="token number">10937</span><span class="token punctuation">,</span>
    commentCount <span class="token operator">=</span> <span class="token number">3285</span>
<span class="token punctuation">)</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>可以看到，在这段代码中，我们把函数的形参加了进来，形参和实参用“=”连接，建立了两者的对应关系。对比前面Java风格的写法，这样的代码可读性更强了。如果将来你想修改likeCount这个参数，也可以轻松做到。这其实就体现出了Kotlin命名参数的 <strong>可读性</strong> 与 <strong>易维护性</strong> 两个优势。</p> <p>而除了命名参数这个特性，Kotlin还支持 <strong>参数默认值</strong>，这个特性在参数较多的情况下同样有很大的优势：</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">fun</span> <span class="token function">createUser</span><span class="token punctuation">(</span>
    name<span class="token operator">:</span> String<span class="token punctuation">,</span>
    age<span class="token operator">:</span> Int<span class="token punctuation">,</span>
    gender<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
    friendCount<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    feedCount<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    likeCount<span class="token operator">:</span> Long <span class="token operator">=</span> <span class="token number">0L</span><span class="token punctuation">,</span>
    commentCount<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">0</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//..</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>我们可以看到，gender、friendCount、feedCount、likeCount、commentCount这几个参数都被赋予了默认值。这样做的好处就在于，我们在调用的时候可以省很多事情。比如说，下面这段代码就只需要传3个参数，剩余的4个参数没有传，但是Kotlin编译器会自动帮我们填上默认值。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token function">createUser</span><span class="token punctuation">(</span>
    name <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">&quot;Tom&quot;</span></span><span class="token punctuation">,</span>
    age <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">,</span>
    commentCount <span class="token operator">=</span> <span class="token number">3285</span>
<span class="token punctuation">)</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>对于无默认值的参数，编译器会强制要求我们在调用处传参；对于有默认值的参数，则可传可不传。Kotlin这样的特性，在一些场景下就可以极大地提升我们的开发效率。</p> <p>而如果是在Java当中要实现类似的事情，我们就必须手动定义“3个参数的createUser函数”（<strong>即函数重载Overload</strong>），或者是使用Builder设计模式。</p> <h2 id="流程控制"><a href="#流程控制" class="header-anchor">#</a> 流程控制</h2> <p>在Kotlin当中，流程控制主要有if、when、for、 while，这些语句可以控制代码的执行流程。它们也是体现代码逻辑的关键。下面我们就来一一学习下。</p> <h3 id="if"><a href="#if" class="header-anchor">#</a> if</h3> <p>if语句，在程序当中主要是用于逻辑判断。Kotlin当中的if与Java当中的基本一致：</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">val</span> i <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Big&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Small&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

输出结果：
Big

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>可以看到，由于i大于0，所以程序会输出“Big”，这很好理解。不过Kotlin的if，并不是程序语句（Statement）那么简单，它还可以作为 <strong>表达式</strong>（Expression）来使用。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">val</span> i <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">val</span> message <span class="token operator">=</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token string-literal singleline"><span class="token string">&quot;Big&quot;</span></span> <span class="token keyword">else</span> <span class="token string-literal singleline"><span class="token string">&quot;Small&quot;</span></span>

<span class="token function">print</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span>

输出结果：
Big

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>以上的代码其实跟之前的代码差不多，它们做的是同一件事。不同的是，我们把if当作表达式在用，将if判断的结果，赋值给了一个变量。同时，Kotlin编译会根据if表达式的结果自动推导出变量“message”的类型为“String”。这种方式就使得Kotlin的代码更加简洁。</p> <p>而类似的逻辑，如果要用Java来实现的话，我们就必须先在if外面定义一个变量message，然后分别在两个分支内对message赋值：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span>
<span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">&quot;&quot;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    message <span class="token operator">=</span> <span class="token string">&quot;Big&quot;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    message <span class="token operator">=</span> <span class="token string">&quot;Small&quot;</span>
<span class="token punctuation">}</span>

<span class="token function">print</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>这样两相对比下，我们会发现Java的实现方式明显丑陋一些： <strong>不仅代码行数更多，逻辑也松散了</strong>。</p> <p>另外，由于Kotlin当中明确规定了类型分为“可空类型”“不可空类型”，因此，我们会经常遇到可空的变量，并且要判断它们是否为空。我们直接来看个例子：</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">fun</span> <span class="token function">getLength</span><span class="token punctuation">(</span>text<span class="token operator">:</span> String<span class="token operator">?</span><span class="token punctuation">)</span><span class="token operator">:</span> Int <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>text <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> text<span class="token punctuation">.</span>length <span class="token keyword">else</span> <span class="token number">0</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>在这个例子当中，我们把if当作表达式，如果text不为空，我们就算出它的长度；如果它为空，长度就取0。</p> <p>但是，如果你实际使用Kotlin写过代码，你会发现：在Kotlin中，类似这样的判断逻辑出现得非常频繁，如果每次都要写一个完整的if else分支，其实也很麻烦。</p> <p>为此，Kotlin针对这种情况就提供了一种简写，叫做 <strong>Elvis表达式</strong>。</p> <p>当有一个可空的引用时，可以说“如果不是null，就使用它，否则使用某个非空的值”</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">fun</span> <span class="token function">getLength</span><span class="token punctuation">(</span>text<span class="token operator">:</span> String<span class="token operator">?</span><span class="token punctuation">)</span><span class="token operator">:</span> Int <span class="token punctuation">{</span>
  <span class="token keyword">return</span> text<span class="token operator">?</span><span class="token punctuation">.</span>length <span class="token operator">?:</span> <span class="token number">0</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>可以看到，通过Elvis表达式，我们就再也不必写“ <code>if (xxx != null) xxx else xxx</code>”这样的赋值代码了。它在提高代码可读性的同时，还能提高我们的编码效率。</p> <h3 id="when"><a href="#when" class="header-anchor">#</a> when</h3> <p>when语句，在程序当中主要也是用于逻辑判断的。当我们的代码逻辑只有两个分支的时候，我们一般会使用if/else，而在大于两个逻辑分支的情况下，我们使用when。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">val</span> i<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">1</span>

<span class="token keyword">when</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token number">1</span> <span class="token operator">-&gt;</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;一&quot;</span></span><span class="token punctuation">)</span>
    <span class="token number">2</span> <span class="token operator">-&gt;</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;二&quot;</span></span><span class="token punctuation">)</span>
    <span class="token keyword">else</span> <span class="token operator">-&gt;</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;i 不是一也不是二&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

输出结果：
一

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>when语句有点像Java里的switch case语句，不过Kotlin的when更加强大，它同时也可以 <strong>作为表达式，为变量赋值</strong>，如下所示：</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">val</span> i<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">1</span>

<span class="token keyword">val</span> message <span class="token operator">=</span> <span class="token keyword">when</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token number">1</span> <span class="token operator">-&gt;</span> <span class="token string-literal singleline"><span class="token string">&quot;一&quot;</span></span>
    <span class="token number">2</span> <span class="token operator">-&gt;</span> <span class="token string-literal singleline"><span class="token string">&quot;二&quot;</span></span>
    <span class="token keyword">else</span> <span class="token operator">-&gt;</span> <span class="token string-literal singleline"><span class="token string">&quot;i 不是一也不是二&quot;</span></span> <span class="token comment">// 如果去掉这行，会报错</span>
<span class="token punctuation">}</span>

<span class="token function">print</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>另外，与switch不一样的是，when表达式要求它里面的逻辑分支必须是完整的。举个例子，以上的代码，如果去掉else分支，编译器将报错，原因是：i的值不仅仅只有1和2，这两个分支并没有覆盖所有的情况，所以会报错。</p> <p>但逻辑分支是枚举类或者密封类时，覆盖所有情况，可以没有else，讨论到枚举类和密封类时会再次提到。</p> <h3 id="循环迭代-while与for"><a href="#循环迭代-while与for" class="header-anchor">#</a> 循环迭代：while与for</h3> <p>首先while循环，我们一般是用于重复执行某些代码，它在使用上和Java也没有什么区别：</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
    i<span class="token operator">++</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> j <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">do</span> <span class="token punctuation">{</span>
    <span class="token function">println</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span>
    j<span class="token operator">++</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">)</span>

输出结果：
<span class="token number">0</span>
<span class="token number">1</span>
<span class="token number">2</span>
<span class="token number">0</span>
<span class="token number">1</span>
<span class="token number">2</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>但是对于for语句，Kotlin和Java的用法就明显不一样了。</p> <p>在Java当中，for也会经常被用于循环，经常被用来替代while。不过， <strong>Kotlin的for语句更多的是用于“迭代”。</strong> 比如，以下代码就代表了迭代array这个数组里的所有元素，程序会依次打印出：“1、2、3”。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">val</span> array <span class="token operator">=</span> <span class="token function">arrayOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">in</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>而除了迭代数组和集合以外，Kotlin还支持迭代一个“区间”。</p> <p>首先，要定义一个区间，我们可以使用“ <code>..</code>”来连接数值区间的两端，比如“ <code>1..3</code>”就代表从1到3的闭区间，左闭右闭：</p> <div class="language-plain line-numbers-mode"><pre class="language-plain"><code>val oneToThree = 1..3 // 代表 [1, 3]

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>接着，我们就可以使用for语句，来对这个闭区间范围进行迭代：</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">in</span> oneToThree<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

输出结果：
<span class="token number">1</span>
<span class="token number">2</span>
<span class="token number">3</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">..</span><span class="token number">9</span><span class="token punctuation">)</span> <span class="token comment">// include [1,9]</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token number">1</span> until <span class="token number">9</span><span class="token punctuation">)</span> <span class="token comment">// exclude [1,9)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>甚至，我们还可以 <strong>逆序迭代</strong> 一个区间，比如：</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token number">6</span> downTo <span class="token number">0</span> step <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

输出结果：
<span class="token number">6</span>
<span class="token number">4</span>
<span class="token number">2</span>
<span class="token number">0</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>以上代码的含义就是逆序迭代一个区间，从6到0，每次迭代的步长是2，这意味着6迭代过后，到4、2，最后到0。 <strong>需要特别注意的是</strong>，逆序区间我们不能使用“ <code>6..0</code>”来定义，如果用这样的方式来定义的话，代码将无法正常运行。</p> <h2 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h2> <p>现在我们知道虽然Kotlin和Java的语法很像，但在一些细节之处，Kotlin总会有一些新的东西。如果你仔细琢磨这些不同点，你会发现它正是大部分程序员所需要的。举个例子，作为开发者，我们都讨厌写冗余的代码，喜欢简洁易懂的代码。那么在今天学完了基础语法之后，我们可以来看看Kotlin在这方面都做了哪些改进：</p> <ul><li>支持类型推导（smart cast）；</li> <li>代码末尾不需要分号；</li> <li>字符串模板；</li> <li>原始字符串，支持复杂文本格式；</li> <li>单一表达式函数，简洁且符合直觉；</li> <li>函数参数支持默认值，替代Builder模式的同时，可读性还很强；</li> <li>if和when可以作为表达式。</li></ul> <p>同时，JetBrains也非常清楚开发者在什么情况下容易出错，所以，它在语言层面也做了很多改进：</p> <ul><li>强制区分“可为空变量类型”和“不可为空变量类型”，规避空指针异常；</li> <li>推崇不可变性（val），对于没有修改需求的变量，IDE会智能提示开发者将“var”改为“val”；</li> <li>基础类型不支持隐式类型转换，这能避免很多隐藏的问题；</li> <li>数组访问行为与集合统一，不会出现array.length、list.size这种恼人的情况；</li> <li>函数调用支持命名参数，提高可读性，在后续维护代码的时候不易出错；</li> <li>when表达式，强制要求逻辑分支完整，让你写出来的逻辑永远不会有漏洞。</li></ul> <p>这些都是Kotlin的 <strong>闪光点</strong>，也是它最珍贵的地方。</p> <p>这一切，都得益于Kotlin的发明者JetBrains。作为最负盛名的IDE创造者，JetBrains能深刻捕捉到开发者的需求。它知道开发者喜欢什么、讨厌什么，它甚至知道开发者容易犯什么样的错误，从而在语言设计的层面规避错误。站在这个角度看，JetBrains能够创造出炙手可热的Kotlin语言，就一点都不奇怪了。</p> <p>以上这么多的“闪光点”还仅仅只是局限于我们这节课的内容，如果放眼全局，这样的例子更是数不胜数。 <strong>Kotlin对比Java的提升，如果独立去看其中的某一个点，都不足以让一个开发者心动。不过，一旦这样的改善积少成多，Kotlin的优势就会显得尤为明显。</strong> 这也是很多程序员表示“Kotlin用过了就回不去”的原因。</p></div></div> <!----> <div class="page-edit"><div class="edit-link"><a href="https://github.com/saukaguya/blog/edit/main/docs/01.one/01.Kotlin基础语法：正式开启学习之旅.md" target="_blank" rel="noopener noreferrer">帮助我们改善此页面</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">6/11/2024, 10:28:46 PM</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><!----> <a href="/blog/pages/9424ea/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">面向对象：理解Kotlin设计者的良苦用心</div></a></div> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/blog/pages/9424ea/">面向对象：理解Kotlin设计者的良苦用心</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="https://github.com/saukaguya" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="saukaguya0101@gmail.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://gitee.com/saukaguya" title="Gitee" target="_blank" class="iconfont icon-gitee"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2024-2024
    <span>Eryajf | <a href="https://github.com/eryajf/blog/blob/main/LICENSE" target="_blank">MIT License</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><!----></div></div>
    <script src="/blog/assets/js/app.b4e5127e.js" defer></script><script src="/blog/assets/js/2.1e7fad39.js" defer></script><script src="/blog/assets/js/8.a42f8812.js" defer></script>
  </body>
</html>
